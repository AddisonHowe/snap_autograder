<!DOCTYPE html>
<html>
<head>
    <title>Snap! Build Your Own Blocks. Beta</title>
    <link rel="shortcut icon" href="http://snap.berkeley.edu/fav3.gif" type="image/gif">
    <script src="jschannel.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="http://underscorejs.org/underscore-min.js"></script>
    <script type="text/javascript" src="SnapPLE.js"></script>
    <!-- Moved down to the bottom to have var id. -->
    
    <script type="text/javascript" src="snap.js"></script>

    <link rel="stylesheet" type="text/css" href="AG_status_bar.css" />
    <link rel="stylesheet" type="text/css" href="hintstyle.css" />
    <script type="text/javascript" src="AG_hint_format.js"></script>

    <script type="text/javascript">
        // The id is to act as a course identifier.
        // NOTE: FOR NOW YOU ALSO HAVE TO ADD THE ID TO THE BOTTOM OF THE PAGE.
        var courseID = "";  // e.g. "BJCx"
        // Specify a prerequisite task id, should be null if no such requirement.
        var preReqTaskID = null;
        var preReqID = courseID + preReqTaskID;
        // taskID uniquely identifies the task for saving in browser localStorage.
        var taskID = "AG_D1_T1";
        var id = courseID + taskID;
        var agOutput;

        // Add tests to the outputLog. Function is called by runAGTest(id, outputLog)
        // var testLog;
        function AGTest(outputLog) {
            /*HOW TO LAMBDAIZE:*/
            // var assert1 = function assert1() {
            //     return isScriptPresent('factorial %s',0);
            // }

    /*Lab 1: Introduction*/

        /*Creating a Script*/

            /*Modify given script to make the sprite follow a square path if clicked enough times.*/
            var moveExists = function moveExists() {
                return spriteContainsBlock('move %n steps', 0);
            }
            testAssert(outputLog, moveExists,
                "The 'move' block is present.",
                "The 'move' block was not found on-screen.",
                "Make sure to make your sprite move on the stage.");
            var turnExists = function turnExists() { //counterclockwise is incorrect
                return spriteContainsBlock('turn %clockwise %n degrees', 0);
            }
            testAssert(outputLog, turnExists,
                "The 'turn clockwise' block is present.",
                "The 'turn clockwise' block was not found on-screen.",
                "Make sure you make your sprite turns clockwise on the stage.");
            var turn90 = function turn90() {
                return spriteContainsBlock('turn %clockwise %n degrees', 0, ["90"]);
            }
            testAssert(outputLog, turn90,
                "The turn block has an input of 90 degrees.",
                "The turn block does not have the correct input.",
                "Make sure your sprite turns an appropriate amount.");
            var moveThenTurn = function moveThenTurn() {
                var template1 = '[{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]}]';
                var template2 = '[{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]},{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]}]';
                var template3 = '[{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]},{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]},{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]},{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]}]';
                var vars = ["A"];
                return scriptPresentInSprite(template1, 0, vars) || scriptPresentInSprite(template2, 0, vars) || scriptPresentInSprite(template3, 0, vars);
            }
            testAssert(outputLog, moveThenTurn,
                "'Turn 90' follows the 'move' block in a script.",
                "The 'move' block is not followed by a turn with correct inputs, or the block's sidelengths are inconsistent.",
                "Make sure your sprite moves and then turns with just one click.");
            
            // /*Modify the previous script to make the sprite follow a triangular path if clicked enough times.*/
            // testAssert(outputLog, spriteContainsBlock('move %n steps', 0),
            //     "The 'move' block is present.",
            //     "The 'move' block was not found on-screen.",
            //     "Make sure to make your sprite move on the stage.");
            // testAssert(outputLog, spriteContainsBlock('turn %clockwise %n degrees', 0) || spriteContainsBlock('turn %counterclockwise %n degrees',0),
            //     "The 'turn' block is present.",
            //     "The 'turn' block was not found on-screen.",
            //     "Make sure you make your sprite turn on the stage.");
            // testAssert(outputLog, blockPrecedesInSprite('turn %clockwise %n degrees', 'move %n steps') || blockPrecedesInSprite('move %n steps', 'turn %clockwise %n degrees'),
            //     "The 'move' and 'turn' blocks are in a script together.",
            //     "The 'move' and 'turn' blocks are not in a script together.",
            //     "Make sure you make your sprite move and turn with just one click.");
            // testAssert(outputLog, spriteContainsBlock('turn %clockwise %n degrees', 0, ["60"]) || spriteContainsBlock('turn %counterclockwise %n degrees',0, ["60"]),
            //     "The sprite turns 60 degrees.",
            //     "The sprite does not turn 60 degrees.",
            //     "Make sure your sprite turns an appropriate amount."); //need to make sure the turn 60 is
            //                                                             // the turn attached to the move.

    /*Lab 3: Repeat Commands*/

        /*The Repeat Block*/

            /*Input an argument value into the given script to create the given picture*/
            //"[{"blockSp":"when %greenflag clicked","inputs":[]},{"blockSp":"pen down","inputs":[]},{"blockSp":"repeat %n %c","inputs":["A",[{"blockSp":"move %n steps","inputs":["100"]},{"blockSp":"turn %clockwise %n degrees","inputs":["80"]}]]}]"
            //"["A"]"
            // testAssert(outputLog, spriteContainsBlock("repeat %n %c", 0, ["9", "A"]),
            //     "The input to the repeat loop is 9.",
            //     "The input to the repeat loop is incorrect.",
            //     "Try checking how many sides the given shape has!");
            // //scriptPresentInSprite with a template??

    /*Lab 4: Making Your Own Blocks*/

        /*Adding an Input*/

            /*Add an input to the draw square block.*/
            // testAssert(outputLog, spriteContainsBlock("draw square %s", 0) || spriteContainsBlock("draw square %n", 0) || spriteContainsBlock("draw square %exp", 0),
            //     "There is a 'draw square' block with a parameter.",
            //     "There is no 'draw square' block with a parameter.",
            //     "Make sure to give your 'draw square' block a parameter.");
            // getCustomBody("draw square ----")

            // /*Add an input to the draw triangle block.*/
            // testAssert(outputLog, spriteContainsBlock("draw triangle %s", 0) || spriteContainsBlock("draw triangle %n", 0) || spriteContainsBlock("draw triangle %exp", 0),
            //     "There is a 'draw triangle' block with a parameter.",
            //     "There is no 'draw triangle' block with a parameter.",
            //     "Make sure to give your 'draw triangle' block a parameter.");

            // /*Add an input to the draw house block.*/
            // testAssert(outputLog, spriteContainsBlock("draw house %s", 0) || spriteContainsBlock("draw house %n", 0) || spriteContainsBlock("draw house %exp", 0),
            //     "There is a 'draw house' block with a parameter.",
            //     "There is no 'draw house' block with a parameter.",
            //     "Make sure to give your 'draw house' block a parameter.");

            return outputLog;
        }

        /* Removes the previously saved AG_state. Runs the tests in
         * AGTest().
         * Called by 'click' event on autograder_button.
         */
        function runAGTest(snapWorld, taskID, outputLog) {
            // Create a new gradingLog if none is specified.
            outputLog = outputLog || new gradingLog(snapWorld, taskID);
            // Populate, run, and evaluate the tests specified in AGTest()
            // These tests specified by the Course Designer. 

            var test_log = AGTest(outputLog);
            if(!test_log.runSnapTests()) {
                outputLog.scoreLog();
            }
        }

        /* After loading the XML, check if the current XML is a known
         * state, restore the gradingLog if it is.
         * @return {gradingLog}
         * TODO: Trigger AGStart when a Snap file is loaded.
         */
        function AGStart(snapWorld, taskID) {
            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var outputLog;
            //If the current XML matches the stored correct XML
            if (isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_c_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
                return outputLog;
            }
            //If the current XML matches the last stored gradingLog
            if (isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                return outputLog; 
            } else {
                //Restore the AG status bar to a graded state
                //If no previous state is recognized, return new {gradingLog}.
                outputLog = new gradingLog(snapWorld, taskID); 
                AG_bar_ungraded(outputLog);
                return outputLog;
            }   
        }
        /* Checks to see if the Snap! XML has changed and updates the
         * AG status bar. If Snap! is restored to its former state
         * the grading log and status bar are also restored.
         * @return {gradingLog} outputLog
         * Note:
         *  - Should only be called from a "mouseup" event.
         */
        function AGUpdate(snapWorld, taskID) {

            

            //TODO: Are there any optional parameters that may be useful?
            //Grabs HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            //Retrieve previous grade logs (if in localStorage). As {String}s
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (!prev_xml || !curr_xml) {
                console.log(prev_xml);
                console.log(curr_xml);
            }


            //menu bar grays out options that are not available (ex. current state is same as best attempt) and restores the button state

            var last_submit = document.getElementById("last-submit");
            if (last_xml === null || isSameSnapXML(last_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var undo_button = document.getElementById("undo-button");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                undo_button.style.color = "#373737";
                undo_button.style.pointerEvents = "none";
                undo_button.parentNode.id = "disabled-button";
            } else {
                undo_button.parentNode.id = "enabled-button";
                undo_button.style.color = "white";
                undo_button.style.pointerEvents = "auto";
            }

            var outputLog;
            //If current XML is different from prev_xml
            if (c_prev_xml && isSameSnapXML(c_prev_xml, curr_xml)) {               
                //Restore the AG status bar to a graded state
                
                // TODO: Write a good comment
                // TODO: Give gradeLog ability to recover log data and xml string
                localStorage.setItem(taskID + "_test_log", c_prev_log);
                localStorage.setItem(taskID + "_test_state", curr_xml);
                document.getElementById("different-feedback").innerHTML = "";

                //Retrieve the correct test log from localStorage
                outputLog = JSON.parse(c_prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
 
            } else if (prev_xml && isSameSnapXML(prev_xml, curr_xml, true)) {
                //Restore the AG status bar to a graded state
                //Retrieve the previous test log from localStorage
                document.getElementById("different-feedback").innerHTML = "";

                outputLog = JSON.parse(prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);

            } else {
                //Restore the AG status bar to a graded state
                outputLog = new gradingLog(snapWorld, taskID);
                AG_bar_ungraded(outputLog);
                document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."

            }
            populateFeedback(outputLog);
            return outputLog;

        }

        /* Updates the AG_status_bar with respect to the outputLog. 
         *  - Formats CSS for 'autograding_flag' and 'autograding_button'
         * If the outputLog is correct, save the Snap XML string into 
         * localStorage.
         *  - key = outputLog.taskID + "_c_test_state"
         * Note:
         *  - Should only be called from outputLog.evaluateLog()
         */
        function AGFinish(outputLog) {

            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            // Verify correctness
            if (outputLog.allCorrect) {
                // Update AG_status_bar to Passing state
                // Save the correct XML string into localStorage
                AG_bar_graded(outputLog);
                outputLog.saveSnapXML(outputLog.taskID + "_c_test_state");

            } else {
                // Update AG_status_bar to 'graded, but incorrect state
                AG_bar_semigraded(outputLog);
            }
            outputLog.saveSnapXML(outputLog.taskID + "_test_state");
            populateFeedback(outputLog);
            console.log('Autograder test Results:');
            console.log(outputLog);
        }



        function AG_bar_ungraded(outputLog) {
            
            var button_text = "GRADE";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'orange');
            });          
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("View Previous Feedback");
        }

        function AG_bar_graded(outputLog) {
            var button_text = "TESTS PASS";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', '#29A629');
            });
            $('#autograding_button .hover_darken').hide();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("Review Feedback");

        }

        function AG_bar_semigraded(outputLog) {
            var button_text = "&#x2770&#x2770 FEEDBACK";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp("FEEDBACK","g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'red');
            });
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'orange');
            var num_errors = outputLog.testCount - outputLog.numCorrect;
            var plural = "";
            if (num_errors > 1) { plural = "s"};
            $('#feedback-button').html("View Feedback ("+ 
                num_errors +" Error" + plural + ")");
        }

        /* Checks if two Snap! XML strings have approximately the same state.
         * The positions of scripts are ignored, as well as the order in which
         * they were most recently manipulated. 
         * @param {String} prev_xml
         * @param {String} curr_xml
         * @return {Boolean} Equivalence of prev_xml and curr_xml, false if
         * either are strings are undefined.
         * Currently only works for one sprite with scripts
         * TODO: Extend to all script groups [DONE]
         * TODO: Improve XML scrubbing (Consider the following)
         *  - If correct solution (scripts) is subset of other [DONE]
         *  - Optional tags for variables, sprite position  
         *  - Option to restore the highest scoring {gradingLog}
         *  
         * Note: Apparently works with multiple sprites, but produces a malformed
         * Snap XML string. Each sprite gets all scripts in sorted order. Needs
         * further testing.
        */
        function isSameSnapXML(prev_xml, curr_xml, no_subset) {
            //replace script coordinates with generic 'x="0" y="0"'
            // console.log('isSameSnapXML');
            if ((prev_xml === null) || (curr_xml === null)) {
                console.log("isSameSnapXML: prev_xml or curr_xml are null");
                console.log(prev_xml);
                console.log(curr_xml);
                return false;
            }
            
            //Remove script coordinates
            // prev_xml = prev_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            // curr_xml = curr_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            prev_xml = prev_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            curr_xml = curr_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');

            //Remove data hashes hashes (to allow coherence b/w reloads).
            prev_xml = prev_xml.replace(/data:image(.*?)(?=<)/g, '');
            curr_xml = curr_xml.replace(/data:image(.*?)(?=<)/g, '');

            // console.log('previous XML');
            // console.log(prev_xml);
            // console.log('current XML');
            // console.log(curr_xml);
            // console.log("They are the same:" + String(prev_xml === curr_xml));
            if (prev_xml === curr_xml) {
                return true;
            }

            //split between brackets
            prev_xml_scripts = prev_xml.match(/(<script x)(.*?)(<\/script>)/g);
            curr_xml_scripts = curr_xml.match(/(<script x)(.*?)(<\/script>)/g);

            //split between custom blocks
            prev_xml_blocks = prev_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            curr_xml_blocks = curr_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            
            //sort script tags and convert back to strings
            //lol. weird syntax. doesn't sort if curr_xml_scripts === null.
            prev_xml_scripts && prev_xml_scripts.sort().join("");
            curr_xml_scripts && curr_xml_scripts.sort().join("");

            //If the custom block definitions have changed
            prev_xml_blocks && prev_xml_blocks.sort().join("");
            curr_xml_blocks && curr_xml_blocks.sort().join("");
            if(JSON.stringify(prev_xml_blocks) !== JSON.stringify(curr_xml_blocks)) {
                return false;
            }

            //If the previous scripts are a subset of current scripts
            if (!no_subset && isArrSubset(curr_xml_scripts, prev_xml_scripts)) {
                //Then the solution is still present and in-tact
                return true;
            }

            //replace unsorted scripts with sorted scripts
            //TODO: Replace them properly
            prev_xml = prev_xml.replace(/(<script x)(.*)(<\/script>)/g,prev_xml_scripts);
            curr_xml = curr_xml.replace(/(<script x)(.*)(<\/script>)/g,curr_xml_scripts);

            return prev_xml === curr_xml;
        }

        function isArrSubset(big, small) {
            if (!big || !small) {
                return false;
            }
            nbig = big.slice();
            var index;
            for (var elem of small) {
                index = nbig.indexOf(elem);
                if (nbig.indexOf(elem) >= 0) {
                    nbig.slice(index, 1);
                } else {
                    return false;
                }
            }
            return true;
        }

        function escapeRegExp(string) {
            return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceall(string, find, replace) {
            return (string.replace(new RegExp(escapeRegExp(find), 'g'), replace));
        }

        /*
         * Re-format the contents of a the hint string to add HTML tags and
         * appropriate CSS. Return the re-formatted string.
         */
        function formatFeedback(hint) {
            var tags = 
            [['collapsedivstart', '<input class="toggle-box" id="expander" type="checkbox" ><label for="expander">Details</label><div id="table-wrapper">'], 
            ['collapsedivend', '</div>'], 
            ['linebreak', '<br /></br />'], 
            ['tablestart', '<table class="results">'], 
            ['tableend', '</table>'], 
            ['rowstart', '<tr>'], 
            ['rowend', '</tr>'], 
            ['headstart', '<th class="titles" style="text-align: center;">'], 
            ['headend', '</th>'], 
            ['datastart', '<td class="data" style="text-align: center;">'], 
            ['dataend', '</td>'], 
            ['correctstart', '<td class="correctans" style="text-align: center;">'],
            ['wrongstart', '<td class="incorrectans" style="text-align: center;">'],
            ['teststart', '<td class="tests" style="text-align: center;">'],
            ['spanend', '</span>'], 
            ['spanstart', '<span class="message">']];

            var taglength = tags.length;
            var message = String(hint.innerHTML);

            for (var i = 0; i < taglength; i++) {
                message = replaceall(message, tags[i][0], tags[i][1]);
            }
            return message;
        }

        function resetState(snapWorld, taskID) {

            localStorage.removeItem(taskID + "_test_log");
            localStorage.removeItem(taskID + "_test_state");
            localStorage.removeItem(taskID + "_c_test_log");
            localStorage.removeItem(taskID + "_c_test_state");

            var ide = snapWorld.children[0];
            ide.newProject();
            var new_log = AGStart(snapWorld, taskID);
            populateFeedback(new_log);
        }

        function revertToBestState(snapWorld, taskID) {
    
            var ide = snapWorld.children[0];

            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            localStorage.setItem(taskID + "_test_state", c_prev_xml);
            localStorage.setItem(taskID + "_test_log", c_prev_log);

            var prev_log = JSON.parse(c_prev_log);
            prev_log.snapWorld = snapWorld;
            AG_bar_graded(prev_log);
            populateFeedback(prev_log);
            ide.openProjectString(c_prev_xml);
        }

        function revertToLastState(snapWorld, taskID) {

            var ide = snapWorld.children[0];
            var prev_xml = localStorage.getItem(taskID + "_test_state");
            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            ide.openProjectString(prev_xml);
        }

        function revertToLastSubmit(snapWorld, taskID) {
            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var ide = snapWorld.children[0];

            localStorage.setItem(taskID + "_test_state", last_xml);
            localStorage.setItem(taskID + "_test_log", last_log);
            var prev_log = JSON.parse(last_log);
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            ide.openProjectString(last_xml);

        }

        function toggleMenu() {
            var menu_items = document.getElementsByClassName("bubble")[0];
            if (menu_items.id === "dropdown-closed") {
                menu_items.id = "dropdown-open";
            } else {
                menu_items.id = "dropdown-closed";
            }
        }

        function openPopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.remove("is-hidden");
        }

        function closePopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.add("is-hidden");
        }

        function openResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.remove("is-hidden");
        }

        function closeResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.add("is-hidden");
        }

        function populateFeedback(outputLog) {
            var taskID = outputLog.taskID;
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            var edx_caution = document.getElementById("edx-submit-different");
            var caution = document.getElementById("different-feedback");

            var glog = outputLog;
            var log = AG_log(glog);
            var feedback = log["feedback"];
            var title = log["comment"];

            if (title === "Please run the Snap Autograder before clicking the 'Submit' button.") {
                document.getElementById("table-data").style.display = "none";
                document.getElementById("reporter-table-data").style.display = "none";
            } else {
                document.getElementById("table-data").style.display = "table";
                document.getElementById("reporter-table-data").style.display = "table";
            }

            caution.innerHTML = "";
            edx_caution.innerHTML = "";
            document.getElementById("comment").innerHTML = "";
            var tableTitles = document.getElementsByClassName("titles");
            var tableResults = document.getElementById("table-data");
            var repTableResults = document.getElementById("reporter-table-data");
            while (tableResults.children.length > 1) {
                tableResults.removeChild(tableResults.children[1]);
            }
            while (repTableResults.children.length > 1) {
                repTableResults.removeChild(repTableResults.children[1]);
            }

            document.getElementById("comment").innerHTML = title;
            if (!last_log) {
                edx_caution.innerHTML = "[WARNING: You have not submitted your results to edX yet.]"
            }
            else if (last_log !== prev_log) {
                edx_caution.innerHTML = "[WARNING: These results differ from your last edX submission.]"
            }

            var nonRepTest = 1;
            var repTest = 1;
            for (i=1; i<=feedback["testCount"]; i++) {
                var test = String(i);
                var newRow = document.createElement("tr");

                if (feedback[test]["testClass"] !== "r") {
                    if (document.getElementsByClassName("non-reporter").length === 0) {
                        addBasicHeadings();
                    }
                    addTableCell(String(nonRepTest), "tests", newRow);
                    nonRepTest += 1;
                }

                if (feedback[test]["testClass"] === "r") {
                    if (document.getElementsByClassName("reporter").length === 0) {
                        addReporterHeadings();
                    }
                    addTableCell(String(repTest), "tests", newRow);
                    repTest += 1;
                    var keys = ["input", "output", "expOut"];
                    for (key=0; key<3; key++) {
                        addTableCell(feedback[test][keys[key]], "data", newRow);
                    }
                }
                if (feedback[test]["correct"] === true) {
                    addTableCell(feedback[test]["feedback"], "correctans", newRow);
                } else {
                    addTableCell(feedback[test]["feedback"], "incorrectans", newRow);
                }

                if (feedback[test]["testClass"] === "r") {
                    document.getElementById("reporter-table-data").appendChild(newRow);
                } else {
                    document.getElementById("table-data").appendChild(newRow);
                }
            }
        }

        function addBasicHeadings() {
            basicCols = ["Test", "Feedback"];
            for (i=0; i<2; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(basicCols[i]);
                //var lastCol = document.getElementById("reporter-last-column");
                var titles = document.getElementById("table-titles");
                header.classList.add("titles", "non-reporter");
                header.appendChild(text);
                titles.appendChild(header);
            }
        }

        function addReporterHeadings() {
            var columns = ["Test", "Input", "Output", "Expected", "Feedback"];
            for (i=0; i<5; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(columns[i]);
                var repTitles = document.getElementById("reporter-table-titles");
                header.classList.add("titles", "reporter");
                header.appendChild(text);
                repTitles.appendChild(header);
            }
        }

        function addTableCell(text, elemClass, row) {
            var data = document.createElement("td");
            var text = document.createTextNode(text);
            data.appendChild(text);
            data.classList.add(elemClass);
            row.appendChild(data);
        }


        var world;
        window.onload = function () {

            //AUTOGRADER ADDITION - FEEDBACK FORMATTING
            // Checks if problem has been checked and modifies the autograded output if it has been checked

            if (parent.document.getElementsByClassName("message").length !== 0) {
                var hint = parent.document.getElementsByClassName("message")[0];
                hint.innerHTML = formatFeedback(hint);
                hint.style.display = "inline";
            }


            //INITIALIZE UP SNAP
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);


            var ide = world.children[0];
            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);

            //AUTOGRADER ADDITION
            //Check if Pre-requisite task has completed
            var req_check = parent.document.getElementById("pre_req");
            if (preReqTaskID !== null) {
                var preReqLog = JSON.parse(localStorage.getItem(preReqID + "_test_log"));
                if ((preReqLog === null || !preReqLog.allCorrect) && req_check) {
                    req_check.innerHTML = "[WARNING: The previous task must be completed before continuing.]"
                }
            }

            //If page has already been loaded, restore previously tested XML
            //TODO: Separate this into its own function.
            var prev_xml = localStorage.getItem(id + "_test_state");
            if (prev_xml !== null) {
                ide.openProjectString(prev_xml);
            } else if (preReqTaskID !== null) {
                if (preReqLog !== null && preReqLog.allCorrect) {
                    ide.openProjectString(localStorage.getItem(preReqID));
                }
            }
            setInterval(loop, 1);

            //AUTOGRADER ADDITION - 
            //Forced to use setTimeout() to let the world load before... Maybe not.
            
            //Create a gradingLog and initialize the AG status bar (AGSB).
            // var testLog = AGStart(world, id);

            //Initialize AGSB button.
            var grade_button = document.getElementById("autograding_button");
            grade_button.style.cursor = "pointer";
            //Call the test suite when this element is clicked.
            var update_listener = function() {
                AGUpdate(world, id);
            };
            var button_listener = function(event) {
                event.stopPropagation();
                runAGTest(world,id);
                // var outputLog = AGStart(world, id);
            }
            grade_button.addEventListener('click', button_listener);
            var world_canvas = document.getElementById('world');
            world_canvas.addEventListener("mouseup", update_listener);

            // grade_button.onclick = function(event) {
            //     // event.stopPropagation();
            //     runAGTest(world, id);
            //     var outputLog = AGStart(world, id);
            //     //console.log(outputLog);
            //     //populateFeedback(outputLog);
            // }



            var reset_button = document.getElementById("reset-button");
            var revert_button = document.getElementById("revert-button");
            var undo_button = document.getElementById("undo-button");
            var last_submit = document.getElementById("last-submit");
            var menu_button = document.getElementsByClassName("onclick-menu")[0];
            //var help_menu = document.getElementById("circle");
            var help_overlay = document.getElementById('overlay');
            var feedback_button = document.getElementById("feedback-button");
            var results_overlay = document.getElementById("ag-output");

            reset_button.onclick = function() { resetState(world, id); };
            revert_button.onclick = function() { revertToBestState(world, id); };
            last_submit.onclick = function() { revertToLastSubmit(world, id); };
            undo_button.onclick = function() { revertToLastState(world, id); };
            menu_button.onclick = function() { toggleMenu(id); };

            feedback_button.onclick = function() {
                openResults();
            }

            help_overlay.onclick = function(e) {
                if (!(document.getElementById('help-popup').contains(e.target))) {
                    closePopup();
                }
            }

            results_overlay.onclick = function(e) {
                if (!(document.getElementById('ag-results').contains(e.target))) {
                    closeResults();
                }
            }

            /*help_menu.onclick = function() {
                openModal();
            }*/
            /* Check if the snap xml has changed "significantly".
             * Exclude script position and edit history.
             */
            

            


            /*document.addEventListener("click", function() {
                AGUpdate(world, id);
            });*/
            //TODO: Fix this timeout.
            setTimeout(function() {
                console.log(world);
                var outputLog = AGStart(world,id);
                populateFeedback(outputLog);
                populateFeedback(outputLog);
                //var outputLog = AGStart(world,id);
                //populateFeedback(outputLog);

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so runAGTest has to be called twice at the very beginning...
                //runAGTest(world,id);
                //runAGTest(world,id);
                //AGUpdate(world, id);
            },300);

            //runAGTest(world,id);
            //AGUpdate(world, id);

            
            
        };

        function loop() {
            world.doOneCycle();
        }

    </script>
    <script type="text/javascript" src="AG_EDX.js"></script>
</head>
<body style="margin: 0;">
    <canvas id="world" tabindex="1" style="position: absolute;" ></canvas>



<!-- Snap Autograding Button -->
<div id="autograding_bar">
    <div tabindex="0" class="onclick-menu" id='onclick-menu' style="display:inline-block">
        <span title="Menu">&#9776;</span>
        <div class='hover_darken'></div>
      <nav id="navigation" class="site-navigation" role="navigation">
          <ul id="dropdown-closed" class="bubble">
            <li class="menu-item-sub-menu" id="enabled-button"><a id="feedback-button">View Feedback</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="revert-button">Revert To Best Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="last-submit">Revert To Last edX Submission</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="undo-button">Revert To Last Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="reset-button">Reset</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id='enabled-button' onclick="openPopup();"><a id="help-button">Help</a></li>
          </ul>
    </nav>
    </div>
    <!-- <div id="autograding_flag" style="display:inline-block"></div> -->
    <!-- <div style="display:inline-block"> -->
    <div id="autograding_button" style="display:inline-block;">
        <span></span>
        <div class='hover_darken'></div>
    </div>
    <!-- </div> -->


<!-- Snap Autograding Menu -->

</div>

<!-- Autograding Menu Help Button -->
<!-- <div style="display:inline-block" class="AG-help-button" id="circle" onclick="openPopup();">?
</div> -->
<div class="overlay is-hidden" id="overlay">
    <div class="popup-content" id="help-popup">
        <span class="button-close" onclick="closePopup();">X</span>
            <p>
                Please remember to click the 'Submit' button below the Snap! window to obtain credit for this problem!
            </p>
            <div class="example-ag-buttons" id="ex-ungraded" style="display:inline-block;">
                &#9744;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has not been run yet.
            </p>
            </br>
            <div style="display:inline-block; color: orange;">&#x26A0;</div>
            <div class="example-ag-buttons" id="ex-semigraded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, but there are some errors in the code.
            </p>
            </br>
            <div class="example-ag-buttons" id="ex-graded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, and all the tests have passed!
            </p>
            </br>
    </div>
</div>

<div style="display:inline-block" class="view-results" id="circle" onclick="openResults();">Results
</div>
<div class="overlay is-hidden" id="ag-output">
    <div class="popup-content" id="ag-results">
        <span class="button-close" onclick="closeResults();" id="popup">X</span>
        <p id = "different-feedback"></p>
        <p id = "edx-submit-different"></p>
        <p id="comment"></p>
        <table class="results">
            <tbody id="table-data">
                <tr id="table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
        </br>
        <table class="results">
            <tbody id="reporter-table-data">
                <tr id="reporter-table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
    </div>
</div>


    </div>
    <script type="text/javascript" src="AG_status_bar.js" />
</body>
</html>