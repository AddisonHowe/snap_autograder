<!DOCTYPE html>
<html>
<head>
    <title>Snap! Build Your Own Blocks. Beta</title>
    <link rel="shortcut icon" href="http://snap.berkeley.edu/fav3.gif" type="image/gif">
    <script src="jschannel.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="http://underscorejs.org/underscore-min.js"></script>
    <script type="text/javascript" src="SnapPLE.js"></script>
    <!-- Moved down to the bottom to have var id. -->
    
    <script type="text/javascript" src="snap.js"></script>

    <link rel="stylesheet" type="text/css" href="AG_status_bar.css" />
    <link rel="stylesheet" type="text/css" href="hintstyle.css" />
    <link type="text/javascript" src="AG_hint_format.js"></script>

    <script type="text/javascript">
        // The id is to act as a course identifier.
        // NOTE: FOR NOW YOU ALSO HAVE TO ADD THE ID TO THE BOTTOM OF THE PAGE.
        var courseID = "";  // e.g. "BJCx"
        // Specify a prerequisite task id, should be null if no such requirement.
        var preReqTaskID = null;
        var preReqID = courseID + preReqTaskID;
        // taskID uniquely identifies the task for saving in browser localStorage.
        var taskID = "AG_D1_T1";
        var id = courseID + taskID;

        // Add tests to the outputLog. Function is called by runAGTest(id, outputLog)
        // var testLog;
        function AGTest(outputLog) {
            
            testAssert(outputLog, isScriptPresent('move %n steps',0), 
                "Move block is present", //Positive statement
                "Don't forget the move block!", //Negative statement
                "Make sure you have all required blocks."); //General assertion text
            // testAssert(outputLog, isScriptPresent('turn %clockwise %n degrees',0), 
            //     "Turn block is present", //Positive statement
            //     "Don't forget the turn block!", //Negative statement
            //     "Make sure you have all required blocks."); //General assertion text

            testScriptPresent('[{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]}]', ["A"], 0, outputLog);
            multiTestBlock("%s my plus %s",[[1,2],[2,2],[2,3],[3,4],[5,5]],[3,4,5,7,10],[-1,-1,-1,-1,-1], outputLog);
            // return outputLog;
            return outputLog;
        }

        /* Removes the previously saved AG_state. Runs the tests in
         * AGTest().
         * Called by 'click' event on autograder_button.
         */
        function runAGTest(snapWorld, taskID, outputLog) {
            // Create a new gradingLog if none is specified.
            outputLog = outputLog || new gradingLog(snapWorld, taskID);
            // Populate, run, and evaluate the tests specified in AGTest()
            // These tests specified by the Course Designer. 

            var test_log = AGTest(outputLog);
            if(!test_log.runSnapTests()) {
                outputLog.scoreLog();
            }
        }

        /* After loading the XML, check if the current XML is a known
         * state, restore the gradingLog if it is.
         * @return {gradingLog}
         * TODO: Trigger AGStart when a Snap file is loaded.
         */
        function AGStart(snapWorld, taskID) {
            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var outputLog;
            //If the current XML matches the stored correct XML
            if (isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_c_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
                return outputLog;
            }
            //If the current XML matches the last stored gradingLog
            if (isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                return outputLog; 
            } else {
                //Restore the AG status bar to a graded state
                //If no previous state is recognized, return new {gradingLog}.
                outputLog = new gradingLog(snapWorld, taskID); 
                AG_bar_ungraded(outputLog);
                return outputLog;
            }   
        }
        /* Checks to see if the Snap! XML has changed and updates the
         * AG status bar. If Snap! is restored to its former state
         * the grading log and status bar are also restored.
         * @return {gradingLog} outputLog
         * Note:
         *  - Should only be called from a "mouseup" event.
         */
        function AGUpdate(snapWorld, taskID) {


            

            //TODO: Are there any optional parameters that may be useful?
            //Grabs HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            //Retrieve previous grade logs (if in localStorage). As {String}s
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (!prev_xml || !curr_xml) {
                console.log(prev_xml);
                console.log(curr_xml);
            }


            //menu bar grays out options that are not available (ex. current state is same as best attempt) and restores the button state

            var last_submit = document.getElementById("last-submit");
            if (last_xml === null || isSameSnapXML(last_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var undo_button = document.getElementById("undo-button");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                undo_button.style.color = "#373737";
                undo_button.style.pointerEvents = "none";
                undo_button.parentNode.id = "disabled-button";
            } else {
                undo_button.parentNode.id = "enabled-button";
                undo_button.style.color = "white";
                undo_button.style.pointerEvents = "auto";
            }

            var outputLog;
            //If current XML is different from prev_xml
            if (c_prev_xml && isSameSnapXML(c_prev_xml, curr_xml)) {               
                //Restore the AG status bar to a graded state
                AG_bar_graded(menu_button, grade_button);
                // TODO: Write a good comment
                // TODO: Give gradeLog ability to recover log data and xml string

                localStorage.setItem(taskID + "_test_log", c_prev_log);
                localStorage.setItem(taskID + "_test_state", curr_xml);

                document.getElementById("different-feedback").innerHTML = "";

                //Retrieve the correct test log from localStorage
                outputLog = JSON.parse(c_prev_log);
                outputLog.snapWorld = snapWorld;
                return outputLog;
            }
            //If current XML is same as prev correct
            if (prev_xml && isSameSnapXML(prev_xml, curr_xml, true)) {
                //Restore the AG status bar to a graded state

                
                //Retrieve the previous test log from localStorage

                document.getElementById("different-feedback").innerHTML = "";

                outputLog = JSON.parse(prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                return outputLog;
            } else {
                //Restore the AG status bar to a graded state
                
                outputLog = new gradingLog(snapWorld, taskID);
                AG_bar_ungraded(outputLog);
                document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."
                return outputLog
            }

        }

        /* Updates the AG_status_bar with respect to the outputLog. 
         *  - Formats CSS for 'autograding_flag' and 'autograding_button'
         * If the outputLog is correct, save the Snap XML string into 
         * localStorage.
         *  - key = outputLog.taskID + "_c_test_state"
         * Note:
         *  - Should only be called from outputLog.evaluateLog()
         */
        function AGFinish(outputLog) {

            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            // Verify correctness
            if (outputLog.allCorrect) {
                // Update AG_status_bar to Passing state
                // Save the correct XML string into localStorage
                AG_bar_graded(outputLog);
                outputLog.saveSnapXML(outputLog.taskID + "_c_test_state");

            } else {
                // Update AG_status_bar to 'graded, but incorrect state
                AG_bar_semigraded(outputLog);
            }
            outputLog.saveSnapXML(outputLog.taskID + "_test_state");
            console.log(outputLog);
        }



        function AG_bar_ungraded(outputLog) {
            
            var button_text = "GRADE";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'orange');
            });          
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("View Previous Feedback");
        }

        function AG_bar_graded(outputLog) {
            var button_text = "TESTS PASS";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', '#29A629');
            });
            $('#autograding_button .hover_darken').hide();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("Review Feedback");

        }

        function AG_bar_semigraded(outputLog) {
            var button_text = "&#x2770&#x2770 FEEDBACK";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp("FEEDBACK","g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'red');
            });
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'orange');
            var num_errors = outputLog.testCount - outputLog.numCorrect;
            var plural = "";
            if (num_errors > 1) { plural = "s"};
            $('#feedback-button').html("View Feedback ("+ 
                num_errors +" Error" + plural + ")");
        }

        /* Checks if two Snap! XML strings have approximately the same state.
         * The positions of scripts are ignored, as well as the order in which
         * they were most recently manipulated. 
         * @param {String} prev_xml
         * @param {String} curr_xml
         * @return {Boolean} Equivalence of prev_xml and curr_xml, false if
         * either are strings are undefined.
         * Currently only works for one sprite with scripts
         * TODO: Extend to all script groups [DONE]
         * TODO: Improve XML scrubbing (Consider the following)
         *  - If correct solution (scripts) is subset of other [DONE]
         *  - Optional tags for variables, sprite position  
         *  - Option to restore the highest scoring {gradingLog}
         *  
         * Note: Apparently works with multiple sprites, but produces a malformed
         * Snap XML string. Each sprite gets all scripts in sorted order. Needs
         * further testing.
        */
        function isSameSnapXML(prev_xml, curr_xml, no_subset) {
            //replace script coordinates with generic 'x="0" y="0"'
            if ((prev_xml === null) || (curr_xml === null)) {
                console.log("isSameSnapXML: prev_xml or curr_xml are null");
                console.log(prev_xml);
                console.log(curr_xml);
                return false;
            }
            
            //Remove script coordinates
            prev_xml = prev_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            curr_xml = curr_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            //Remove data hashes hashes (to allow coherence b/w reloads).
            prev_xml = prev_xml.replace(/data:image(.*?)(?=<)/g, '');
            curr_xml = curr_xml.replace(/data:image(.*?)(?=<)/g, '');

            //split between brackets
            prev_xml_scripts = prev_xml.match(/(<script x)(.*?)(<\/script>)/g);
            curr_xml_scripts = curr_xml.match(/(<script x)(.*?)(<\/script>)/g);
            
            //sort script tags and convert back to strings
            //lol. weird syntax. doesn't sort if curr_xml_scripts === null.
            prev_xml_scripts && prev_xml_scripts.sort().join("");
            curr_xml_scripts && curr_xml_scripts.sort().join("");

            //If the previous scripts are a subset of current scripts
            if (!no_subset && isArrSubset(curr_xml_scripts, prev_xml_scripts)) {
                //Then the solution is still present and in-tact
                return true;
            }

            //replace unsorted scripts with sorted scripts
            //TODO: Replace them properly
            prev_xml = prev_xml.replace(/(<script x)(.*)(<\/script>)/g,prev_xml_scripts);
            curr_xml = curr_xml.replace(/(<script x)(.*)(<\/script>)/g,curr_xml_scripts);
            // console.log(prev_xml);
            // console.log(curr_xml);

            return prev_xml === curr_xml;
        }

        function isArrSubset(big, small) {
            if (!big || !small) {
                return false;
            }
            nbig = big.slice();
            var index;
            for (var elem of small) {
                index = nbig.indexOf(elem);
                if (nbig.indexOf(elem) >= 0) {
                    nbig.slice(index, 1);
                } else {
                    return false;
                }
            }
            return true;
        }

        function escapeRegExp(string) {
            return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceall(string, find, replace) {
            return (string.replace(new RegExp(escapeRegExp(find), 'g'), replace));
        }

        /*
         * Re-format the contents of a the hint string to add HTML tags and
         * appropriate CSS. Return the re-formatted string.
         */
        function formatFeedback(hint) {
            var tags = 
            [['collapsedivstart', '<input class="toggle-box" id="expander" type="checkbox" ><label for="expander">Details</label><div id="table-wrapper">'], 
            ['collapsedivend', '</div>'], 
            ['linebreak', '<br /></br />'], 
            ['tablestart', '<table class="results">'], 
            ['tableend', '</table>'], 
            ['rowstart', '<tr>'], 
            ['rowend', '</tr>'], 
            ['headstart', '<th class="titles" style="text-align: center;">'], 
            ['headend', '</th>'], 
            ['datastart', '<td class="data" style="text-align: center;">'], 
            ['dataend', '</td>'], 
            ['correctstart', '<td class="correctans">'],
            ['wrongstart', '<td class="incorrectans">'],
            ['teststart', '<td class="tests">'],
            ['spanend', '</span>'], 
            ['spanstart', '<span class="message">']];

            var taglength = tags.length;
            var message = String(hint.innerHTML);

            for (var i = 0; i < taglength; i++) {
                message = replaceall(message, tags[i][0], tags[i][1]);
            }
            return message;
        }

        function resetState(snapWorld, taskID) {

            localStorage.removeItem(taskID + "_test_log");
            localStorage.removeItem(taskID + "_test_state");
            localStorage.removeItem(taskID + "_c_test_log");
            localStorage.removeItem(taskID + "_c_test_state");

            var ide = snapWorld.children[0];
            ide.newProject();
            AGStart(snapWorld, taskID);
        }

        function revertToBestState(snapWorld, taskID) {
    
            var ide = snapWorld.children[0];

            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            localStorage.setItem(taskID + "_test_state", c_prev_xml);
            localStorage.setItem(taskID + "_test_log", c_prev_log);
            var prev_log = JSON.parse(c_prev_log);
            prev_log.snapWorld = snapWorld;
            AG_bar_graded(prev_log);

            ide.openProjectString(c_prev_xml);
        }

        function revertToLastState(snapWorld, taskID) {

            var ide = snapWorld.children[0];
            var prev_xml = localStorage.getItem(taskID + "_test_state");
            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            ide.openProjectString(prev_xml);
        }

        function revertToLastSubmit(snapWorld, taskID) {
            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var ide = snapWorld.children[0];

            localStorage.setItem(taskID + "_test_state", last_xml);
            localStorage.setItem(taskID + "_test_log", last_log);
            var prev_log = JSON.parse(last_log);
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            ide.openProjectString(last_xml);

        }

        function toggleMenu() {
            var menu_items = document.getElementsByClassName("bubble")[0];
            if (menu_items.id === "dropdown-closed") {
                menu_items.id = "dropdown-open";
            } else {
                menu_items.id = "dropdown-closed";
            }
        }

        function openPopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.remove("is-hidden");
        }

        function closePopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.add("is-hidden");
        }

        function openResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.remove("is-hidden");
        }

        function closeResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.add("is-hidden");
        }

        function populateFeedback(outputLog) {
            var taskID = outputLog.taskID;
            var ide = world.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            var prev_xml = localStorage.getItem(taskID + "_test_state");
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");

            var edx_caution = document.getElementById("edx-submit-different");
            var caution = document.getElementById("different-feedback");

            //if the feedback is not the same as it was before

                var glog = outputLog;
                var log = AG_log(glog);

                //var log = JSON.parse(localStorage.getItem(taskID + "_ag_output"));
                var feedback = log["feedback"];
                var title = log["comment"];
                var hasReporter = false;

                for (i=1; i<=feedback["testCount"]; i++) {
                    var test = String(i);
                    if (feedback[test]["testClass"] === "r") {
                        hasReporter = true;
                    }
                }

                

                if (document.getElementById("last-column") !== null) {
                    caution.innerHTML = "";
                    edx_caution.innerHTML = "";
                    document.getElementById("comment").innerHTML = "";
                    var tableTitles = document.getElementsByClassName("titles");
                    var tableResults = document.getElementById("table-data");
                    if (tableTitles.length !== 2 && hasReporter === false) {
                        while (tableTitles.length > 2) {
                            document.getElementById("table-titles").removeChild(tableTitles[1]);
                        }
                    }
                    while (tableResults.children.length > 1) {
                        tableResults.removeChild(tableResults.children[1]);
                    }
                        //document.getElementById("table-titles").innerHTML = "";
                } else {
                    var testCol = document.createElement("th");
                    var testColText = document.createTextNode("Test");
                    testCol.appendChild(testColText);
                    testCol.classList.add("titles");
                    document.getElementById("table-titles").appendChild(testCol);

                    var feedbackCol = document.createElement("th");
                    var feedbackColText = document.createTextNode("Feedback");
                    feedbackCol.appendChild(feedbackColText);
                    feedbackCol.classList.add("titles");
                    feedbackCol.setAttribute("id", "last-column");
                    document.getElementById("table-titles").appendChild(feedbackCol);
                }

                document.getElementById("comment").innerHTML = title;

                if (last_log !== prev_log) {
                    edx_caution.innerHTML = "[WARNING: These results differ from your last edX submission.]"
                }

                /*var testCol = document.createElement("th");
                var testColText = document.createTextNode("Test");
                testCol.appendChild(testColText);
                testCol.classList.add("titles");
                document.getElementById("table-titles").appendChild(testCol);

                var feedbackCol = document.createElement("th");
                var feedbackColText = document.createTextNode("Feedback");
                feedbackCol.appendChild(feedbackColText);
                feedbackCol.classList.add("titles");
                feedbackCol.setAttribute("id", "last-column");
                document.getElementById("table-titles").appendChild(feedbackCol);*/


                /*var comment = document.createElement("p");
                var commentText = document.createTextNode(title);
                comment.appendChild(commentText);
                document.getElementById("ag-results").appendChild(comment);*/

                var testString = "";

                

                if (hasReporter === true) {
                    addTableHeadings();
                }

                for (i=1; i<=feedback["testCount"]; i++) {
                    var test = String(i);
                    /*if (feedback[test]["testClass"] === "r") {
                        addTableHeadings();
                    }*/

                    // Is it possible to put a key in the log that will say whether or not any of the tests is a reporter test? 


                    

                    var newRow = document.createElement("tr");

                    var testNum = document.createElement("td");
                    var testNumText = document.createTextNode(test);
                    testNum.appendChild(testNumText);
                    testNum.classList.add("tests");
                    newRow.appendChild(testNum);
                    //document.getElementById("table-data").appendChild(newRow);

                    if (hasReporter === true) {
                        for (key in ["input", "output", "expOut"]) {
                            var tableData = document.createElement("td");
                            if (feedback[test]["testClass"] === "r") {
                                var tableDataText = document.createTextNode(feedback[test][key]);
                            } else {
                                var tableDataText = document.createTextNode("N/A");
                            }
                            tableData.appendChild(tableDataText);
                            tableData.classList.add("data");
                            newRow.appendChild(tableData);
                        }
                    }

                    var agFeedback = document.createElement("td");
                    var agFeedbackText = document.createTextNode(feedback[test]["feedback"]);
                    agFeedback.appendChild(agFeedbackText);
                    if (feedback[test]["correct"] === true) {
                        agFeedback.classList.add("correctans");
                    } else {
                        agFeedback.classList.add("incorrectans");
                    }
                    newRow.appendChild(agFeedback);
                    document.getElementById("table-data").appendChild(newRow);

                    testString += test;
                    testString += feedback[test]["feedback"];
                    //testString += feedback[test]
                }
                /*var output = title + testString;
                var table = document.createElement("p");
                var agOutput = document.createTextNode(output);
                table.appendChild(agOutput);
                document.getElementById("ag-results").appendChild(table);*/

                /*var header = document.createElement("th");
                var text = document.createTextNode("hello");
                var lastCol = document.getElementById("last-column");
                var titles = document.getElementById("table-titles");
                header.classList.add("titles");
                header.appendChild(text);
                titles.insertBefore(header, lastCol);*/
            //}
        }

        function addTableHeadings() {
            for (key in ["Input", "Output", "Expected"]) {
                var header = document.createElement("th");
                var text = document.createTextNode(key);
                var lastCol = document.getElementById("last-column");
                var titles = document.getElementById("table-titles");
                header.classList.add("titles");
                header.appendChild(text);
                titles.insertBefore(header, lastCol);
            }
        }

        var world;
        window.onload = function () {

            //AUTOGRADER ADDITION - FEEDBACK FORMATTING
            // Checks if problem has been checked and modifies the autograded output if it has been checked
            if (parent.document.getElementsByClassName("message").length !== 0) {
                var hint = parent.document.getElementsByClassName("message")[0];
                hint.innerHTML = formatFeedback(hint);
                hint.style.display = "inline";
            }


            //INITIALIZE UP SNAP
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);


            var ide = world.children[0];
            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);

            //AUTOGRADER ADDITION
            //Check if Pre-requisite task has completed
            var req_check = parent.document.getElementById("pre_req");
            if (preReqTaskID !== null) {
                var preReqLog = JSON.parse(localStorage.getItem(preReqID + "_test_log"));
                if ((preReqLog === null || !preReqLog.allCorrect) && req_check) {
                    req_check.innerHTML = "[WARNING: The previous task must be completed before continuing.]"
                }
            }

            //If page has already been loaded, restore previously tested XML
            //TODO: Separate this into its own function.
            var prev_xml = localStorage.getItem(id + "_test_state");
            if (prev_xml !== null) {
                ide.openProjectString(prev_xml);
            } else if (preReqTaskID !== null) {
                if (preReqLog !== null && preReqLog.allCorrect) {
                    ide.openProjectString(localStorage.getItem(preReqID));
                }
            }
            setInterval(loop, 1);

            //AUTOGRADER ADDITION - 
            //Forced to use setTimeout() to let the world load before... Maybe not.
            
            //Create a gradingLog and initialize the AG status bar (AGSB).
            // var testLog = AGStart(world, id);

            //Initialize AGSB button.
            var grade_button = document.getElementById("autograding_button");
            grade_button.style.cursor = "pointer";
            //Call the test suite when this element is clicked.
            grade_button.onclick = function() {
                runAGTest(world, id);
                populateFeedback(id);
            }


            var reset_button = document.getElementById("reset-button");
            var revert_button = document.getElementById("revert-button");
            var undo_button = document.getElementById("undo-button");
            var last_submit = document.getElementById("last-submit");
            var menu_button = document.getElementsByClassName("onclick-menu")[0];
            //var help_menu = document.getElementById("circle");
            var help_overlay = document.getElementById('overlay');
            var feedback_button = document.getElementById("feedback-button");
            var results_overlay = document.getElementById("ag-output");

            reset_button.onclick = function() { resetState(world, id); };
            revert_button.onclick = function() { revertToBestState(world, id); };
            last_submit.onclick = function() { revertToLastSubmit(world, id); };
            undo_button.onclick = function() { revertToLastState(world, id); };
            menu_button.onclick = function() { toggleMenu(id); };

            feedback_button.onclick = function() {
                openResults();
            }

            help_overlay.onclick = function(e) {
                if (!(document.getElementById('help-popup').contains(e.target))) {
                    closePopup();
                }
            }

            results_overlay.onclick = function(e) {
                if (!(document.getElementById('ag-results').contains(e.target))) {
                    closeResults();
                }
            }

            /*help_menu.onclick = function() {
                openModal();
            }*/
            /* Check if the snap xml has changed "significantly".
             * Exclude script position and edit history.
             */
            document.addEventListener("mouseup", function() {
                AGUpdate(world, id);
                //populateFeedback(id);
            });

            


            /*document.addEventListener("click", function() {
                AGUpdate(world, id);
            });*/
            //TODO: Fix this timeout.
            setTimeout(function() {
                console.log(world);
                var outputLog = AGStart(world,id);
                populateFeedback(outputLog);
            },300);
            
            
        };

        function loop() {
            world.doOneCycle();
        }

    </script>
    <script type="text/javascript" src="AG_EDX.js"></script>
</head>
<body style="margin: 0;">
    <canvas id="world" tabindex="1" style="position: absolute;" ></canvas>



<!-- Snap Autograding Button -->
<div id="autograding_bar">
    <div tabindex="0" class="onclick-menu" id='onclick-menu' style="display:inline-block">
        <span title="Menu">&#9776;</span>
        <div class='hover_darken'></div>
      <nav id="navigation" class="site-navigation" role="navigation">
          <ul id="dropdown-closed" class="bubble">
            <li class="menu-item-sub-menu" id="enabled-button"><a id="feedback-button">View Feedback</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="revert-button">Revert To Best Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="last-submit">Revert To Last edX Submission</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="undo-button">Revert To Last Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="reset-button">Reset</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id='enabled-button' onclick="openPopup();"><a id="help-button">Help</a></li>
          </ul>
    </nav>
    </div>
    <!-- <div id="autograding_flag" style="display:inline-block"></div> -->
    <!-- <div style="display:inline-block"> -->
    <div id="autograding_button" style="display:inline-block;">
        <span></span>
        <div class='hover_darken'></div>
    </div>
    <!-- </div> -->


<!-- Snap Autograding Menu -->

</div>

<!-- Autograding Menu Help Button -->
<!-- <div style="display:inline-block" class="AG-help-button" id="circle" onclick="openPopup();">?
</div> -->
<div class="overlay is-hidden" id="overlay">
    <div class="popup-content" id="help-popup">
        <span class="button-close" onclick="closePopup();">X</span>
            <p>
                Please remember to click the 'Submit' button below the Snap! window to obtain credit for this problem!
            </p>
            <div class="example-ag-buttons" id="ex-ungraded" style="display:inline-block;">
                &#9744;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has not been run yet.
            </p>
            </br>
            <div style="display:inline-block; color: orange;">&#x26A0;</div>
            <div class="example-ag-buttons" id="ex-semigraded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, but there are some errors in the code.
            </p>
            </br>
            <div class="example-ag-buttons" id="ex-graded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, and all the tests have passed!
            </p>
            </br>
    </div>
</div>

<div style="display:inline-block" class="view-results" id="circle" onclick="openResults();">Results
</div>
<div class="overlay is-hidden" id="ag-output">
    <div class="popup-content" id="ag-results">
        <span class="button-close" onclick="closeResults();" id="popup">X</span>
        <p id = "different-feedback"></p>
        <p id = "edx-submit-different"></p>
        <p id="comment"></p>
        <table class="results">
            <tbody id="table-data">
                <tr id="table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
    </div>
</div>


    </div>
    <script type="text/javascript" src="AG_status_bar.js" />
</body>
</html>
