<!DOCTYPE html>
<html>
<head>
    <title>Snap! Build Your Own Blocks. Beta</title>
    <link rel="shortcut icon" href="http://snap.berkeley.edu/fav3.gif" type="image/gif">
    <script src="jschannel.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="http://underscorejs.org/underscore-min.js"></script>
    <script type="text/javascript" src="SnapPLE.js"></script>
    <!-- Moved down to the bottom to have var id. -->
    
    <script type="text/javascript" src="snap.js"></script>

    <link rel="stylesheet" type="text/css" href="AG_status_bar.css" />
    <link type="text/javascript" src="AG_hint_format.js"></script>

    <script type="text/javascript">
        // The id is to act as a course identifier.
        // NOTE: FOR NOW YOU ALSO HAVE TO ADD THE ID TO THE BOTTOM OF THE PAGE.
        var courseID = "";  // e.g. "BJCx"
        // Specify a prerequisite task id, should be null if no such requirement.
        var preReqTaskID = null;
        var preReqID = courseID + preReqTaskID;
        // taskID uniquely identifies the task for saving in browser localStorage.
        var taskID = "AG_D1_T1";
        var id = courseID + taskID;

        // Add tests to the outputLog. Function is called by runAGTest(id, outputLog)
        // var testLog;
        function AGTest(outputLog) {
            
            testScriptPresent('[{"blockSp":"move %n steps","inputs":["A"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]}]', ["A"], 0, outputLog);
            // testLog = multiTestBlock("%s my plus %s",[[1,2],[2,2],[2,3],[3,4],[5,5]],[3,4,5,7,10],[-1,-1,-1,-1,-1]);
            // return outputLog;
        }

        /* Removes the previously saved AG_state. Runs the tests in
         * AGTest().
         * Called by 'click' event on autograder_button.
         */
        function runAGTest(snapWorld, taskID, outputLog) {
            // Create a new gradingLog if none is specified.
            outputLog = outputLog || new gradingLog(snapWorld, taskID);
            // Populate, run, and evaluate the tests specified in AGTest()
            // These tests specified by the Course Designer. 
            AGTest(outputLog);
            //Save the Snap XML string
            outputLog.saveSnapXML(taskID + "_test_state");
        }

        /* After loading the XML, check if the current XML is a known
         * state, restore the gradingLog if it is.
         * @return {gradingLog}
         * TODO: Trigger AGStart when a Snap file is loaded.
         */
        function AGStart(snapWorld, taskID) {
            //Grab HTML divs
            var grade_flag = document.getElementById("autograding_flag");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var outputLog;
            //If the current XML matches the stored correct XML
            // console.log("Current XML");
            // console.log(curr_xml);
            // console.log(isSameSnapXML(c_prev_xml, curr_xml));
            if (isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                AG_bar_graded(grade_flag, grade_button);
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_c_test_log"));
                outputLog.snapWorld = snapWorld;
                return outputLog;
            }
            //If the current XML matches the last stored gradingLog
            if (isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                AG_bar_semigraded(grade_flag, grade_button);
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_test_log"));
                outputLog.snapWorld = snapWorld;
                return outputLog; 
            } else {
                //Restore the AG status bar to a graded state
                AG_bar_ungraded(grade_flag, grade_button);
                //If no previous state is recognized, return new {gradingLog}.
                outputLog = new gradingLog(snapWorld, taskID); 
                return outputLog;
            }   
        }
        /* Checks to see if the Snap! XML has changed and updates the
         * AG status bar. If Snap! is restored to its former state
         * the grading log and status bar are also restored.
         * @return {gradingLog} outputLog
         * Note:
         *  - Should only be called from a "mouseup" event.
         */
        function AGUpdate(snapWorld, taskID) {


            

            //TODO: Are there any optional parameters that may be useful?
            //Grabs HTML divs
            var grade_flag = document.getElementById("autograding_flag");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");
            //Retrieve previous grade logs (if in localStorage). As {String}s
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (!prev_xml || !curr_xml) {
                console.log(prev_xml);
                console.log(curr_xml);
            }


            //menu bar grays out options that are not available (ex. current state is same as best attempt)

            var last_submit = document.getElementById("last-submit");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var outputLog;
            //If current XML is different from prev_xml
            if (c_prev_xml && isSameSnapXML(c_prev_xml, curr_xml)) {               
                //Restore the AG status bar to a graded state
                AG_bar_graded(grade_flag, grade_button);
                // TODO: Write a good comment
                // TODO: Give gradeLog ability to recover log data and xml string
                localStorage.setItem(taskID + "_test_log", c_prev_log);
                localStorage.setItem(taskID + "_test_state", curr_xml);
                //Retrieve the correct test log from localStorage
                outputLog = JSON.parse(c_prev_log);
                outputLog.snapWorld = snapWorld;
                return outputLog;
            }
            //If current XML is same as prev correct
            if (prev_xml && isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                AG_bar_semigraded(grade_flag, grade_button);
                //Retrieve the previous test log from localStorage
                outputLog = JSON.parse(prev_log);
                outputLog.snapWorld = snapWorld;
                return outputLog;
            } else {
                //Restore the AG status bar to a graded state
                AG_bar_ungraded(grade_flag, grade_button);
                outputLog = new gradingLog(snapWorld, taskID);
                return outputLog
            }
        }

        /* Updates the AG_status_bar with respect to the outputLog. 
         *  - Formats CSS for 'autograding_flag' and 'autograding_button'
         * If the outputLog is correct, save the Snap XML string into 
         * localStorage.
         *  - key = outputLog.taskID + "_c_test_state"
         * Note:
         *  - Should only be called from outputLog.evaluateLog()
         */
        function AGFinish(outputLog) {
            //Grab HTML divs
            var grade_flag = document.getElementById("autograding_flag");
            var grade_button = document.getElementById("autograding_button");
            // Verify correctness
            if (outputLog.allCorrect) {
                // Update AG_status_bar to Passing state
                // Save the correct XML string into localStorage
                AG_bar_graded(grade_flag, grade_button);
                outputLog.saveSnapXML(outputLog.taskID + "_c_test_state");
            } else {
                // Update AG_status_bar to 'graded, but incorrect state
                AG_bar_semigraded(grade_flag, grade_button);
            }
        }

        function AG_bar_ungraded(grade_flag, grade_button) {
            grade_flag.innerHTML = "";
            grade_flag.style.color = "#FF3333"
            //grade_button.innerHTML = "&#x2713;";
            grade_button.innerHTML = "&#9744;";
            grade_button.style.color = "#FF3333";
            grade_button.style.background = "#FF3333";
            grade_button.style.font = "1.2em";
            grade_button.style.padding = "2px 3px 0px 3px";
            /*grade_button.style.border = "4px gray solid";*/
        }

        function AG_bar_graded(grade_flag, grade_button) {
            //grade_flag.innerHTML = "READY TO BE CHECKED";
            grade_flag.innerHTML = "";
            grade_flag.style.color = "#33FF33";
            grade_button.style.font = "1.2em";
            grade_button.style.color = "white";
            grade_button.style.background = "#33FF33";
            grade_button.innerHTML = "&#x2713;";
            grade_button.style.padding = "2px 3px 0px 3px";
            /*grade_button.style.border = "4px gray solid";*/
        }

        function AG_bar_semigraded(grade_flag, grade_button) {
            //grade_flag.innerHTML = "READY TO BE CHECKED";
            grade_flag.innerHTML = "&#x26A0;";
            grade_flag.style.color = "orange";
            grade_button.style.font = "1.4em";
            grade_button.style.color = "black";
            grade_button.style.background = "orange";
            grade_button.style.padding = "2px 3px 0px 3px";
            grade_button.innerHTML = "&#x2713;";
            /*grade_button.style.border = "4px gray solid";*/
        }

        /* Checks if two Snap! XML strings have approximately the same state.
         * The positions of scripts are ignored, as well as the order in which
         * they were most recently manipulated. 
         * @param {String} prev_xml
         * @param {String} curr_xml
         * @return {Boolean} Equivalence of prev_xml and curr_xml, false if
         * either are strings are undefined.
         * Currently only works for one sprite with scripts
         * TODO: Extend to all script groups [DONE]
         * TODO: Improve XML scrubbing (Consider the following)
         *  - If correct solution (scripts) is subset of other [DONE]
         *  - Optional tags for variables, sprite position  
         *  - Option to restore the highest scoring {gradingLog}
         *  
         * Note: Apparently works with multiple sprites, but produces a malformed
         * Snap XML string. Each sprite gets all scripts in sorted order. Needs
         * further testing.
        */
        function isSameSnapXML(prev_xml, curr_xml) {
            //replace script coordinates with generic 'x="0" y="0"'
            if ((prev_xml === null) || (curr_xml === null)) {
                console.log("isSameSnapXML: prev_xml or curr_xml are null");
                console.log(prev_xml);
                console.log(curr_xml);
                return false;
            }
            
            //Remove script coordinates
            prev_xml = prev_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            curr_xml = curr_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            //Remove data hashes hashes (to allow coherence b/w reloads).
            prev_xml = prev_xml.replace(/data:image(.*?)(?=<)/g, '');
            curr_xml = curr_xml.replace(/data:image(.*?)(?=<)/g, '');

            //split between brackets
            prev_xml_scripts = prev_xml.match(/(<script x)(.*?)(<\/script>)/g);
            curr_xml_scripts = curr_xml.match(/(<script x)(.*?)(<\/script>)/g);
            
            //sort script tags and convert back to strings
            //lol. weird syntax. doesn't sort if curr_xml_scripts === null.
            prev_xml_scripts && prev_xml_scripts.sort().join("");
            curr_xml_scripts && curr_xml_scripts.sort().join("");

            //If the previous scripts are a subset of current scripts
            if (isArrSubset(curr_xml_scripts, prev_xml_scripts)) {
                //Then the solution is still present and in-tact
                return true;
            }

            //replace unsorted scripts with sorted scripts
            //TODO: Replace them properly
            prev_xml = prev_xml.replace(/(<script x)(.*)(<\/script>)/g,prev_xml_scripts);
            curr_xml = curr_xml.replace(/(<script x)(.*)(<\/script>)/g,curr_xml_scripts);
            // console.log(prev_xml);
            // console.log(curr_xml);

            return prev_xml === curr_xml;
        }

        function isArrSubset(big, small) {
            if (!big || !small) {
                return false;
            }
            nbig = big.slice();
            var index;
            for (var elem of small) {
                index = nbig.indexOf(elem);
                if (nbig.indexOf(elem) >= 0) {
                    nbig.slice(index, 1);
                } else {
                    return false;
                }
            }
            return true;
        }

        function escapeRegExp(string) {
            return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceall(string, find, replace) {
            return (string.replace(new RegExp(escapeRegExp(find), 'g'), replace));
        }

        /*
         * Re-format the contents of a the hint string to add HTML tags and
         * appropriate CSS. Return the re-formatted string.
         */
        function formatFeedback(hint) {
            var tags = 
            [['collapsedivstart', '<input class="toggle-box" id="expander" type="checkbox" ><label for="expander">Details</label><div id="table-wrapper">'], 
            ['collapsedivend', '</div>'], 
            ['linebreak', '<br /></br />'], 
            ['tablestart', '<table class="results">'], 
            ['tableend', '</table>'], 
            ['rowstart', '<tr>'], 
            ['rowend', '</tr>'], 
            ['headstart', '<th class="titles" style="text-align: center;">'], 
            ['headend', '</th>'], 
            ['datastart', '<td class="data" style="text-align: center;">'], 
            ['dataend', '</td>'], 
            ['correctstart', '<td class="correctans">'],
            ['wrongstart', '<td class="incorrectans">'],
            ['teststart', '<td class="tests">'],
            ['spanend', '</span>'], 
            ['spanstart', '<span class="message">']];

            var taglength = tags.length;
            var message = String(hint.innerHTML);

            for (var i = 0; i < taglength; i++) {
                message = replaceall(message, tags[i][0], tags[i][1]);
            }
            return message;
        }

        function resetState() {
            localStorage.removeItem(taskID + "_test_log");
            localStorage.removeItem(taskID + "_test_state");
            AGStart(world,id);

            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);


            var ide = world.children[0];
            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);
        }

        function revertToBestState() {
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);
            var ide = world.children[0];
            ide.toggleStageSize(true);

            var curr_xml = ide.serializer.serialize(ide.stage);
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            localStorage.setItem(taskID + "_test_state", taskID + "_c_test_state");
            localStorage.setItem(taskID + "_test_log", taskID + "_c_test_log");
            ide.openProjectString(c_prev_xml);
            /*if (c_prev_xml !== null && !(isSameSnapXML(c_prev_xml, curr_xml))) {
                localStorage.setItem(taskID + "_test_state", taskID + "_c_test_state");
                localStorage.setItem(taskID + "_test_log", taskID + "_c_test_log");
                ide.openProjectString(c_prev_xml);
            } /*else {
                var revert_button = document.getElementById("revert-button");
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled";
            }*/
        }

        function revertToLastSubmit() {
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);
            var ide = world.children[0];
            ide.toggleStageSize(true);

            var prev_xml = localStorage.getItem(taskID + "_test_state");
            var curr_xml = ide.serializer.serialize(ide.stage);
            ide.openProjectString(prev_xml);
            /*if (prev_xml !== null && !(isSameSnapXML(prev_xml, curr_xml))) {
                ide.openProjectString(prev_xml);
            } /*else {
                var last_submit = document.getElementById("last-submit");
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled";
            }*/
        }

        function toggleMenu() {
            var menu_items = document.getElementsByClassName("bubble")[0];
            if (menu_items.id === "dropdown-closed") {
                menu_items.id = "dropdown-open";
            } else {
                menu_items.id = "dropdown-closed";
            }
        }

        var world;
        window.onload = function () {

            //AUTOGRADER ADDITION - FEEDBACK FORMATTING
            // Checks if problem has been checked and modifies the autograded output if it has been checked
            if (parent.document.getElementsByClassName("message").length !== 0) {
                var hint = parent.document.getElementsByClassName("message")[0];
                hint.innerHTML = formatFeedback(hint);
                hint.style.display = "inline";
            }


            //INITIALIZE UP SNAP
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);


            var ide = world.children[0];
            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);

            //AUTOGRADER ADDITION
            //Check if Pre-requisite task has completed
            var req_check = parent.document.getElementById("pre_req");
            if (preReqTaskID !== null) {
                var preReqLog = JSON.parse(localStorage.getItem(preReqID + "_test_log"));
                if ((preReqLog === null || !preReqLog.allCorrect) && req_check) {
                    req_check.innerHTML = "[WARNING: The previous task must be completed before continuing.]"
                }
            }

            //If page has already been loaded, restore previously tested XML
            //TODO: Separate this into its own function.
            var prev_xml = localStorage.getItem(id + "_test_state");
            if (prev_xml !== null) {
                ide.openProjectString(prev_xml);
            } else if (preReqTaskID !== null) {
                if (preReqLog !== null && preReqLog.allCorrect) {
                    ide.openProjectString(localStorage.getItem(preReqID));
                }
            }
            setInterval(loop, 1);

            //AUTOGRADER ADDITION - 
            //Forced to use setTimeout() to let the world load before... Maybe not.
            
            //Create a gradingLog and initialize the AG status bar (AGSB).
            // var testLog = AGStart(world, id);

            //Initialize AGSB button.
            var grade_button = document.getElementById("autograding_button");
            grade_button.style.cursor = "pointer";
            //Call the test suite when this element is clicked.
            grade_button.onclick = function() {
                runAGTest(world, id);
            }

            var reset_button = document.getElementById("reset-button");
            var revert_button = document.getElementById("revert-button");
            var last_submit = document.getElementById("last-submit");
            var menu_button = document.getElementsByClassName("onclick-menu")[0];

            reset_button.onclick = function() {
                resetState();
            }

            revert_button.onclick = function() { 
                revertToBestState();
            }

            last_submit.onclick = function() {
                revertToLastSubmit();
            }

            menu_button.onclick = function() {
                toggleMenu();
            }
            /* Check if the snap xml has changed "significantly".
             * Exclude script position and edit history.
             */
            document.addEventListener("mouseup", function() {
                AGUpdate(world, id);
            });

            document.addEventListener("click", function() {
                AGUpdate(world, id);
            });
            //TODO: Fix this timeout.
            setTimeout(function() {
                console.log(world);
                AGStart(world,id);
            },300);
            
            
        };

        function loop() {
            world.doOneCycle();
        }

    </script>
    <script type="text/javascript" src="AG_EDX.js"></script>
</head>
<body style="margin: 0;">
    <canvas id="world" tabindex="1" style="position: absolute;" ></canvas>
    <div id="autograding_bar">
        <div id="autograding_flag" style="display:inline-block">
            Unchecked
        </div>
        <div id="autograding_button" style="display:inline-block; color:white;">
            <!--&#x2713;   #FF3333-->
            &#9633;
        </div>

<div tabindex="0" class="onclick-menu" style="display:inline-block">&#9776;
  <nav id="navigation" class="site-navigation" role="navigation">
  <!--<ul class="menu">
    <li class="menu-item"><a href="#" id="grading-menu">&#9660</a>-->
      <ul id="dropdown-closed" class="bubble">
        <li class="menu-item-sub-menu" id="enabled-button"><a href="#" id="revert-button">Revert To Best Attempt</a></li>
        <li class="menu-item-sub-menu" id="enabled-button"><a href="#" id="last-submit">Revert To Last Submission</a></li>
        <li class="menu-item-sub-menu" id="enabled-button"><a href="#" id="reset-button">Reset</a></li>
      </ul>
    <!--</li>
  </ul>-->
</nav>
</div>

<!--<div id="circle" style="display:inline-block"></div>-->


    </div>
    <script type="text/javascript" src="AG_status_bar.js" />
</body>
</html>
